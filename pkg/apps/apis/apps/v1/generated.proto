
// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = 'proto2';

package github.com.openshift.origin.pkg.apps.apis.apps.v1;

import "github.com/openshift/origin/pkg/authorization/apis/authorization/v1/generated.proto";
import "github.com/openshift/origin/pkg/build/apis/build/v1/generated.proto";
import "k8s.io/apimachinery/pkg/api/resource/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/schema/generated.proto";
import "k8s.io/apimachinery/pkg/util/intstr/generated.proto";

// Package-wide variables from generator "generated".
option go_package = "v1";

message AWSElasticBlockStoreVolumeSource {
  // Unique ID of the persistent disk resource in AWS (Amazon EBS volume).
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
  optional string volumeID = 1;

  // Filesystem type of the volume that you want to mount.
  // Tip: Ensure that the filesystem type is supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
  // TODO: how do we prevent errors in the filesystem from compromising the machine
  // +optional
  optional string fsType = 2;

  // The partition in the volume that you want to mount.
  // If omitted, the default is to mount by volume name.
  // Examples: For volume /dev/sda1, you specify the partition as "1".
  // Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
  // +optional
  optional int32 partition = 3;

  // Specify "true" to force and set the ReadOnly property in VolumeMounts to "true".
  // If omitted, the default is "false".
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
  // +optional
  optional bool readOnly = 4;
}

message Affinity {
  // Describes node affinity scheduling rules for the pod.
  // +optional
  optional NodeAffinity nodeAffinity = 1;

  // Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
  // +optional
  optional PodAffinity podAffinity = 2;

  // Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
  // +optional
  optional PodAntiAffinity podAntiAffinity = 3;
}

message AzureDiskVolumeSource {
  // The Name of the data disk in the blob storage
  optional string diskName = 1;

  // The URI the data disk in the blob storage
  optional string diskURI = 2;

  // Host Caching mode: None, Read Only, Read Write.
  // +optional
  optional string cachingMode = 3;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // +optional
  optional string fsType = 4;

  // Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // +optional
  optional bool readOnly = 5;

  // Expected values Shared: mulitple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
  optional string kind = 6;
}

message AzureFileVolumeSource {
  // the name of secret that contains Azure Storage Account Name and Key
  optional string secretName = 1;

  // Share Name
  optional string shareName = 2;

  // Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // +optional
  optional bool readOnly = 3;
}

message Capabilities {
  // Added capabilities
  // +optional
  repeated string add = 1;

  // Removed capabilities
  // +optional
  repeated string drop = 2;
}

message CephFSVolumeSource {
  // Required: Monitors is a collection of Ceph monitors
  // More info: https://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it
  repeated string monitors = 1;

  // Optional: Used as the mounted root, rather than the full Ceph tree, default is /
  // +optional
  optional string path = 2;

  // Optional: User is the rados user name, default is admin
  // More info: https://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it
  // +optional
  optional string user = 3;

  // Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
  // More info: https://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it
  // +optional
  optional string secretFile = 4;

  // Optional: SecretRef is reference to the authentication secret for User, default is empty.
  // More info: https://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it
  // +optional
  optional github.com.openshift.origin.pkg.build.apis.build.v1.LocalObjectReference secretRef = 5;

  // Optional: Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // More info: https://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it
  // +optional
  optional bool readOnly = 6;
}

message CinderVolumeSource {
  // volume id used to identify the volume in cinder
  // More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
  optional string volumeID = 1;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
  // +optional
  optional string fsType = 2;

  // Optional: Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
  // +optional
  optional bool readOnly = 3;
}

message ConfigMapEnvSource {
  // The ConfigMap to select from.
  optional github.com.openshift.origin.pkg.build.apis.build.v1.LocalObjectReference localObjectReference = 1;

  // Specify whether the ConfigMap must be defined
  // +optional
  optional bool optional = 2;
}

message ConfigMapProjection {
  optional github.com.openshift.origin.pkg.build.apis.build.v1.LocalObjectReference localObjectReference = 1;

  // If unspecified, each key-value pair in the Data field of the referenced
  // ConfigMap will be projected into the volume as a file whose name is the
  // key and content is the value. If specified, the listed keys will be
  // projected into the specified paths, and unlisted keys will not be
  // present. If a key is specified which is not present in the ConfigMap,
  // the volume setup will error unless it is marked optional. Paths must be
  // relative and may not contain the '..' path or start with '..'.
  // +optional
  repeated KeyToPath items = 2;

  // Specify whether the ConfigMap or it's keys must be defined
  // +optional
  optional bool optional = 4;
}

message ConfigMapVolumeSource {
  optional github.com.openshift.origin.pkg.build.apis.build.v1.LocalObjectReference localObjectReference = 1;

  // If unspecified, each key-value pair in the Data field of the referenced
  // ConfigMap will be projected into the volume as a file whose name is the
  // key and content is the value. If specified, the listed keys will be
  // projected into the specified paths, and unlisted keys will not be
  // present. If a key is specified which is not present in the ConfigMap,
  // the volume setup will error unless it is marked optional. Paths must be
  // relative and may not contain the '..' path or start with '..'.
  // +optional
  repeated KeyToPath items = 2;

  // Optional: mode bits to use on created files by default. Must be a
  // value between 0 and 0777. Defaults to 0644.
  // Directories within the path are not affected by this setting.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  // +optional
  optional int32 defaultMode = 3;

  // Specify whether the ConfigMap or it's keys must be defined
  // +optional
  optional bool optional = 4;
}

message Container {
  // Name of the container specified as a DNS_LABEL.
  // Each container in a pod must have a unique name (DNS_LABEL).
  // Cannot be updated.
  optional string name = 1;

  // Docker image name.
  // More info: https://kubernetes.io/docs/concepts/containers/images
  // This field is optional to allow higher level config management to default or override
  // container images in workload controllers like Deployments and StatefulSets.
  // +optional
  optional string image = 2;

  // Entrypoint array. Not executed within a shell.
  // The docker image's ENTRYPOINT is used if this is not provided.
  // Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
  // cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax
  // can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
  // regardless of whether the variable exists or not.
  // Cannot be updated.
  // More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
  // +optional
  repeated string command = 3;

  // Arguments to the entrypoint.
  // The docker image's CMD is used if this is not provided.
  // Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
  // cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax
  // can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
  // regardless of whether the variable exists or not.
  // Cannot be updated.
  // More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
  // +optional
  repeated string args = 4;

  // Container's working directory.
  // If not specified, the container runtime's default will be used, which
  // might be configured in the container image.
  // Cannot be updated.
  // +optional
  optional string workingDir = 5;

  // List of ports to expose from the container. Exposing a port here gives
  // the system additional information about the network connections a
  // container uses, but is primarily informational. Not specifying a port here
  // DOES NOT prevent that port from being exposed. Any port which is
  // listening on the default "0.0.0.0" address inside a container will be
  // accessible from the network.
  // Cannot be updated.
  // +optional
  // +patchMergeKey=containerPort
  // +patchStrategy=merge
  repeated ContainerPort ports = 6;

  // List of sources to populate environment variables in the container.
  // The keys defined within a source must be a C_IDENTIFIER. All invalid keys
  // will be reported as an event when the container is starting. When a key exists in multiple
  // sources, the value associated with the last source will take precedence.
  // Values defined by an Env with a duplicate key will take precedence.
  // Cannot be updated.
  // +optional
  repeated EnvFromSource envFrom = 19;

  // List of environment variables to set in the container.
  // Cannot be updated.
  // +optional
  // +patchMergeKey=name
  // +patchStrategy=merge
  repeated github.com.openshift.origin.pkg.build.apis.build.v1.EnvVar env = 7;

  // Compute Resources required by this container.
  // Cannot be updated.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
  // +optional
  optional github.com.openshift.origin.pkg.build.apis.build.v1.ResourceRequirements resources = 8;

  // Pod volumes to mount into the container's filesystem.
  // Cannot be updated.
  // +optional
  // +patchMergeKey=mountPath
  // +patchStrategy=merge
  repeated VolumeMount volumeMounts = 9;

  // Periodic probe of container liveness.
  // Container will be restarted if the probe fails.
  // Cannot be updated.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  // +optional
  optional Probe livenessProbe = 10;

  // Periodic probe of container service readiness.
  // Container will be removed from service endpoints if the probe fails.
  // Cannot be updated.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  // +optional
  optional Probe readinessProbe = 11;

  // Actions that the management system should take in response to container lifecycle events.
  // Cannot be updated.
  // +optional
  optional Lifecycle lifecycle = 12;

  // Optional: Path at which the file to which the container's termination message
  // will be written is mounted into the container's filesystem.
  // Message written is intended to be brief final status, such as an assertion failure message.
  // Will be truncated by the node if greater than 4096 bytes. The total message length across
  // all containers will be limited to 12kb.
  // Defaults to /dev/termination-log.
  // Cannot be updated.
  // +optional
  optional string terminationMessagePath = 13;

  // Indicate how the termination message should be populated. File will use the contents of
  // terminationMessagePath to populate the container status message on both success and failure.
  // FallbackToLogsOnError will use the last chunk of container log output if the termination
  // message file is empty and the container exited with an error.
  // The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
  // Defaults to File.
  // Cannot be updated.
  // +optional
  optional string terminationMessagePolicy = 20;

  // Image pull policy.
  // One of Always, Never, IfNotPresent.
  // Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
  // Cannot be updated.
  // More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
  // +optional
  optional string imagePullPolicy = 14;

  // Security options the pod should run with.
  // More info: https://kubernetes.io/docs/concepts/policy/security-context/
  // More info: https://git.k8s.io/community/contributors/design-proposals/security_context.md
  // +optional
  optional SecurityContext securityContext = 15;

  // Whether this container should allocate a buffer for stdin in the container runtime. If this
  // is not set, reads from stdin in the container will always result in EOF.
  // Default is false.
  // +optional
  optional bool stdin = 16;

  // Whether the container runtime should close the stdin channel after it has been opened by
  // a single attach. When stdin is true the stdin stream will remain open across multiple attach
  // sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
  // first client attaches to stdin, and then remains open and accepts data until the client disconnects,
  // at which time stdin is closed and remains closed until the container is restarted. If this
  // flag is false, a container processes that reads from stdin will never receive an EOF.
  // Default is false
  // +optional
  optional bool stdinOnce = 17;

  // Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
  // Default is false.
  // +optional
  optional bool tty = 18;
}

message ContainerPort {
  // If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
  // named port in a pod must have a unique name. Name for the port that can be
  // referred to by services.
  // +optional
  optional string name = 1;

  // Number of port to expose on the host.
  // If specified, this must be a valid port number, 0 < x < 65536.
  // If HostNetwork is specified, this must match ContainerPort.
  // Most containers do not need this.
  // +optional
  optional int32 hostPort = 2;

  // Number of port to expose on the pod's IP address.
  // This must be a valid port number, 0 < x < 65536.
  optional int32 containerPort = 3;

  // Protocol for port. Must be UDP or TCP.
  // Defaults to "TCP".
  // +optional
  optional string protocol = 4;

  // What host IP to bind the external port to.
  // +optional
  optional string hostIP = 5;
}

message DownwardAPIProjection {
  // Items is a list of DownwardAPIVolume file
  // +optional
  repeated DownwardAPIVolumeFile items = 1;
}

message DownwardAPIVolumeFile {
  // Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
  optional string path = 1;

  // Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
  // +optional
  optional github.com.openshift.origin.pkg.build.apis.build.v1.ObjectFieldSelector fieldRef = 2;

  // Selects a resource of the container: only resources limits and requests
  // (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
  // +optional
  optional github.com.openshift.origin.pkg.build.apis.build.v1.ResourceFieldSelector resourceFieldRef = 3;

  // Optional: mode bits to use on this file, must be a value between 0
  // and 0777. If not specified, the volume defaultMode will be used.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  // +optional
  optional int32 mode = 4;
}

message DownwardAPIVolumeSource {
  // Items is a list of downward API volume file
  // +optional
  repeated DownwardAPIVolumeFile items = 1;

  // Optional: mode bits to use on created files by default. Must be a
  // value between 0 and 0777. Defaults to 0644.
  // Directories within the path are not affected by this setting.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  // +optional
  optional int32 defaultMode = 2;
}

message EmptyDirVolumeSource {
  // What type of storage medium should back this directory.
  // The default is "" which means to use the node's default medium.
  // Must be an empty string (default) or Memory.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
  // +optional
  optional string medium = 1;

  // Total amount of local storage required for this EmptyDir volume.
  // The size limit is also applicable for memory medium.
  // The maximum usage on memory medium EmptyDir would be the minimum value between
  // the SizeLimit specified here and the sum of memory limits of all containers in a pod.
  // The default is nil which means that the limit is undefined.
  // More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
  // +optional
  optional k8s.io.apimachinery.pkg.api.resource.Quantity sizeLimit = 2;
}

message EnvFromSource {
  // An optional identifer to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
  // +optional
  optional string prefix = 1;

  // The ConfigMap to select from
  // +optional
  optional ConfigMapEnvSource configMapRef = 2;

  // The Secret to select from
  // +optional
  optional SecretEnvSource secretRef = 3;
}

message ExecAction {
  // Command is the command line to execute inside the container, the working directory for the
  // command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
  // not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
  // a shell, you need to explicitly call out to that shell.
  // Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
  // +optional
  repeated string command = 1;
}

message FCVolumeSource {
  // Optional: FC target worldwide names (WWNs)
  // +optional
  repeated string targetWWNs = 1;

  // Optional: FC target lun number
  // +optional
  optional int32 lun = 2;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // TODO: how do we prevent errors in the filesystem from compromising the machine
  // +optional
  optional string fsType = 3;

  // Optional: Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // +optional
  optional bool readOnly = 4;

  // Optional: FC volume world wide identifiers (wwids)
  // Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
  // +optional
  repeated string wwids = 5;
}

message FlexVolumeSource {
  // Driver is the name of the driver to use for this volume.
  optional string driver = 1;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
  // +optional
  optional string fsType = 2;

  // Optional: SecretRef is reference to the secret object containing
  // sensitive information to pass to the plugin scripts. This may be
  // empty if no secret object is specified. If the secret object
  // contains more than one secret, all secrets are passed to the plugin
  // scripts.
  // +optional
  optional github.com.openshift.origin.pkg.build.apis.build.v1.LocalObjectReference secretRef = 3;

  // Optional: Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // +optional
  optional bool readOnly = 4;

  // Optional: Extra command options if any.
  // +optional
  map<string, string> options = 5;
}

message FlockerVolumeSource {
  // Name of the dataset stored as metadata -> name on the dataset for Flocker
  // should be considered as deprecated
  // +optional
  optional string datasetName = 1;

  // UUID of the dataset. This is unique identifier of a Flocker dataset
  // +optional
  optional string datasetUUID = 2;
}

message GCEPersistentDiskVolumeSource {
  // Unique name of the PD resource in GCE. Used to identify the disk in GCE.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  optional string pdName = 1;

  // Filesystem type of the volume that you want to mount.
  // Tip: Ensure that the filesystem type is supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  // TODO: how do we prevent errors in the filesystem from compromising the machine
  // +optional
  optional string fsType = 2;

  // The partition in the volume that you want to mount.
  // If omitted, the default is to mount by volume name.
  // Examples: For volume /dev/sda1, you specify the partition as "1".
  // Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  // +optional
  optional int32 partition = 3;

  // ReadOnly here will force the ReadOnly setting in VolumeMounts.
  // Defaults to false.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  // +optional
  optional bool readOnly = 4;
}

message GitRepoVolumeSource {
  // Repository URL
  optional string repository = 1;

  // Commit hash for the specified revision.
  // +optional
  optional string revision = 2;

  // Target directory name.
  // Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
  // git repository.  Otherwise, if specified, the volume will contain the git repository in
  // the subdirectory with the given name.
  // +optional
  optional string directory = 3;
}

message GlusterfsVolumeSource {
  // EndpointsName is the endpoint name that details Glusterfs topology.
  // More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod
  optional string endpoints = 1;

  // Path is the Glusterfs volume path.
  // More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod
  optional string path = 2;

  // ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions.
  // Defaults to false.
  // More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod
  // +optional
  optional bool readOnly = 3;
}

message HTTPGetAction {
  // Path to access on the HTTP server.
  // +optional
  optional string path = 1;

  // Name or number of the port to access on the container.
  // Number must be in the range 1 to 65535.
  // Name must be an IANA_SVC_NAME.
  optional k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 2;

  // Host name to connect to, defaults to the pod IP. You probably want to set
  // "Host" in httpHeaders instead.
  // +optional
  optional string host = 3;

  // Scheme to use for connecting to the host.
  // Defaults to HTTP.
  // +optional
  optional string scheme = 4;

  // Custom headers to set in the request. HTTP allows repeated headers.
  // +optional
  repeated HTTPHeader httpHeaders = 5;
}

message HTTPHeader {
  // The header field name
  optional string name = 1;

  // The header field value
  optional string value = 2;
}

message Handler {
  // One and only one of the following should be specified.
  // Exec specifies the action to take.
  // +optional
  optional ExecAction exec = 1;

  // HTTPGet specifies the http request to perform.
  // +optional
  optional HTTPGetAction httpGet = 2;

  // TCPSocket specifies an action involving a TCP port.
  // TCP hooks not yet supported
  // TODO: implement a realistic TCP lifecycle hook
  // +optional
  optional TCPSocketAction tcpSocket = 3;
}

message HostAlias {
  // IP address of the host file entry.
  optional string ip = 1;

  // Hostnames for the above IP address.
  repeated string hostnames = 2;
}

message HostPathVolumeSource {
  // Path of the directory on the host.
  // If the path is a symlink, it will follow the link to the real path.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
  optional string path = 1;

  // Type for HostPath Volume
  // Defaults to ""
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
  // +optional
  optional string type = 2;
}

message ISCSIVolumeSource {
  // iSCSI target portal. The portal is either an IP or ip_addr:port if the port
  // is other than default (typically TCP ports 860 and 3260).
  optional string targetPortal = 1;

  // Target iSCSI Qualified Name.
  optional string iqn = 2;

  // iSCSI target lun number.
  optional int32 lun = 3;

  // Optional: Defaults to 'default' (tcp). iSCSI interface name that uses an iSCSI transport.
  // +optional
  optional string iscsiInterface = 4;

  // Filesystem type of the volume that you want to mount.
  // Tip: Ensure that the filesystem type is supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
  // TODO: how do we prevent errors in the filesystem from compromising the machine
  // +optional
  optional string fsType = 5;

  // ReadOnly here will force the ReadOnly setting in VolumeMounts.
  // Defaults to false.
  // +optional
  optional bool readOnly = 6;

  // iSCSI target portal List. The portal is either an IP or ip_addr:port if the port
  // is other than default (typically TCP ports 860 and 3260).
  // +optional
  repeated string portals = 7;

  // whether support iSCSI Discovery CHAP authentication
  // +optional
  optional bool chapAuthDiscovery = 8;

  // whether support iSCSI Session CHAP authentication
  // +optional
  optional bool chapAuthSession = 11;

  // CHAP secret for iSCSI target and initiator authentication
  // +optional
  optional github.com.openshift.origin.pkg.build.apis.build.v1.LocalObjectReference secretRef = 10;

  // Custom iSCSI initiator name.
  // If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
  // <target portal>:<volume name> will be created for the connection.
  // +optional
  optional string initiatorName = 12;
}

message KeyToPath {
  // The key to project.
  optional string key = 1;

  // The relative path of the file to map the key to.
  // May not be an absolute path.
  // May not contain the path element '..'.
  // May not start with the string '..'.
  optional string path = 2;

  // Optional: mode bits to use on this file, must be a value between 0
  // and 0777. If not specified, the volume defaultMode will be used.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  // +optional
  optional int32 mode = 3;
}

message Lifecycle {
  // PostStart is called immediately after a container is created. If the handler fails,
  // the container is terminated and restarted according to its restart policy.
  // Other management of the container blocks until the hook completes.
  // More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
  // +optional
  optional Handler postStart = 1;

  // PreStop is called immediately before a container is terminated.
  // The container is terminated after the handler completes.
  // The reason for termination is passed to the handler.
  // Regardless of the outcome of the handler, the container is eventually terminated.
  // Other management of the container blocks until the hook completes.
  // More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
  // +optional
  optional Handler preStop = 2;
}

message NFSVolumeSource {
  // Server is the hostname or IP address of the NFS server.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
  optional string server = 1;

  // Path that is exported by the NFS server.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
  optional string path = 2;

  // ReadOnly here will force
  // the NFS export to be mounted with read-only permissions.
  // Defaults to false.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
  // +optional
  optional bool readOnly = 3;
}

message NodeAffinity {
  // If the affinity requirements specified by this field are not met at
  // scheduling time, the pod will not be scheduled onto the node.
  // If the affinity requirements specified by this field cease to be met
  // at some point during pod execution (e.g. due to an update), the system
  // may or may not try to eventually evict the pod from its node.
  // +optional
  optional NodeSelector requiredDuringSchedulingIgnoredDuringExecution = 1;

  // The scheduler will prefer to schedule pods to nodes that satisfy
  // the affinity expressions specified by this field, but it may choose
  // a node that violates one or more of the expressions. The node that is
  // most preferred is the one with the greatest sum of weights, i.e.
  // for each node that meets all of the scheduling requirements (resource
  // request, requiredDuringScheduling affinity expressions, etc.),
  // compute a sum by iterating through the elements of this field and adding
  // "weight" to the sum if the node matches the corresponding matchExpressions; the
  // node(s) with the highest sum are the most preferred.
  // +optional
  repeated PreferredSchedulingTerm preferredDuringSchedulingIgnoredDuringExecution = 2;
}

message NodeSelector {
  // Required. A list of node selector terms. The terms are ORed.
  repeated NodeSelectorTerm nodeSelectorTerms = 1;
}

message NodeSelectorRequirement {
  // The label key that the selector applies to.
  optional string key = 1;

  // Represents a key's relationship to a set of values.
  // Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
  optional string operator = 2;

  // An array of string values. If the operator is In or NotIn,
  // the values array must be non-empty. If the operator is Exists or DoesNotExist,
  // the values array must be empty. If the operator is Gt or Lt, the values
  // array must have a single element, which will be interpreted as an integer.
  // This array is replaced during a strategic merge patch.
  // +optional
  repeated string values = 3;
}

message NodeSelectorTerm {
  // Required. A list of node selector requirements. The requirements are ANDed.
  repeated NodeSelectorRequirement matchExpressions = 1;
}

message PersistentVolumeClaimVolumeSource {
  // ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
  optional string claimName = 1;

  // Will force the ReadOnly setting in VolumeMounts.
  // Default false.
  // +optional
  optional bool readOnly = 2;
}

message PhotonPersistentDiskVolumeSource {
  // ID that identifies Photon Controller persistent disk
  optional string pdID = 1;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  optional string fsType = 2;
}

message PodAffinity {
  // If the affinity requirements specified by this field are not met at
  // scheduling time, the pod will not be scheduled onto the node.
  // If the affinity requirements specified by this field cease to be met
  // at some point during pod execution (e.g. due to a pod label update), the
  // system may or may not try to eventually evict the pod from its node.
  // When there are multiple elements, the lists of nodes corresponding to each
  // podAffinityTerm are intersected, i.e. all terms must be satisfied.
  // +optional
  repeated PodAffinityTerm requiredDuringSchedulingIgnoredDuringExecution = 1;

  // The scheduler will prefer to schedule pods to nodes that satisfy
  // the affinity expressions specified by this field, but it may choose
  // a node that violates one or more of the expressions. The node that is
  // most preferred is the one with the greatest sum of weights, i.e.
  // for each node that meets all of the scheduling requirements (resource
  // request, requiredDuringScheduling affinity expressions, etc.),
  // compute a sum by iterating through the elements of this field and adding
  // "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
  // node(s) with the highest sum are the most preferred.
  // +optional
  repeated WeightedPodAffinityTerm preferredDuringSchedulingIgnoredDuringExecution = 2;
}

message PodAffinityTerm {
  // A label query over a set of resources, in this case pods.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector labelSelector = 1;

  // namespaces specifies which namespaces the labelSelector applies to (matches against);
  // null or empty list means "this pod's namespace"
  repeated string namespaces = 2;

  // This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
  // the labelSelector in the specified namespaces, where co-located is defined as running on a node
  // whose value of the label with key topologyKey matches that of any node on which any of the
  // selected pods is running.
  // For PreferredDuringScheduling pod anti-affinity, empty topologyKey is interpreted as "all topologies"
  // ("all topologies" here means all the topologyKeys indicated by scheduler command-line argument --failure-domains);
  // for affinity and for RequiredDuringScheduling pod anti-affinity, empty topologyKey is not allowed.
  // +optional
  optional string topologyKey = 3;
}

message PodAntiAffinity {
  // If the anti-affinity requirements specified by this field are not met at
  // scheduling time, the pod will not be scheduled onto the node.
  // If the anti-affinity requirements specified by this field cease to be met
  // at some point during pod execution (e.g. due to a pod label update), the
  // system may or may not try to eventually evict the pod from its node.
  // When there are multiple elements, the lists of nodes corresponding to each
  // podAffinityTerm are intersected, i.e. all terms must be satisfied.
  // +optional
  repeated PodAffinityTerm requiredDuringSchedulingIgnoredDuringExecution = 1;

  // The scheduler will prefer to schedule pods to nodes that satisfy
  // the anti-affinity expressions specified by this field, but it may choose
  // a node that violates one or more of the expressions. The node that is
  // most preferred is the one with the greatest sum of weights, i.e.
  // for each node that meets all of the scheduling requirements (resource
  // request, requiredDuringScheduling anti-affinity expressions, etc.),
  // compute a sum by iterating through the elements of this field and adding
  // "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
  // node(s) with the highest sum are the most preferred.
  // +optional
  repeated WeightedPodAffinityTerm preferredDuringSchedulingIgnoredDuringExecution = 2;
}

message PodSecurityContext {
  // The SELinux context to be applied to all containers.
  // If unspecified, the container runtime will allocate a random SELinux context for each
  // container.  May also be set in SecurityContext.  If set in
  // both SecurityContext and PodSecurityContext, the value specified in SecurityContext
  // takes precedence for that container.
  // +optional
  optional SELinuxOptions seLinuxOptions = 1;

  // The UID to run the entrypoint of the container process.
  // Defaults to user specified in image metadata if unspecified.
  // May also be set in SecurityContext.  If set in both SecurityContext and
  // PodSecurityContext, the value specified in SecurityContext takes precedence
  // for that container.
  // +optional
  optional int64 runAsUser = 2;

  // Indicates that the container must run as a non-root user.
  // If true, the Kubelet will validate the image at runtime to ensure that it
  // does not run as UID 0 (root) and fail to start the container if it does.
  // If unset or false, no such validation will be performed.
  // May also be set in SecurityContext.  If set in both SecurityContext and
  // PodSecurityContext, the value specified in SecurityContext takes precedence.
  // +optional
  optional bool runAsNonRoot = 3;

  // A list of groups applied to the first process run in each container, in addition
  // to the container's primary GID.  If unspecified, no groups will be added to
  // any container.
  // +optional
  repeated int64 supplementalGroups = 4;

  // A special supplemental group that applies to all containers in a pod.
  // Some volume types allow the Kubelet to change the ownership of that volume
  // to be owned by the pod:
  // 
  // 1. The owning GID will be the FSGroup
  // 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
  // 3. The permission bits are OR'd with rw-rw----
  // 
  // If unset, the Kubelet will not modify the ownership and permissions of any volume.
  // +optional
  optional int64 fsGroup = 5;
}

message PodSpec {
  // List of volumes that can be mounted by containers belonging to the pod.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes
  // +optional
  // +patchMergeKey=name
  // +patchStrategy=merge,retainKeys
  repeated Volume volumes = 1;

  // List of initialization containers belonging to the pod.
  // Init containers are executed in order prior to containers being started. If any
  // init container fails, the pod is considered to have failed and is handled according
  // to its restartPolicy. The name for an init container or normal container must be
  // unique among all containers.
  // Init containers may not have Lifecycle actions, Readiness probes, or Liveness probes.
  // The resourceRequirements of an init container are taken into account during scheduling
  // by finding the highest request/limit for each resource type, and then using the max of
  // of that value or the sum of the normal containers. Limits are applied to init containers
  // in a similar fashion.
  // Init containers cannot currently be added or removed.
  // Cannot be updated.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
  // +patchMergeKey=name
  // +patchStrategy=merge
  repeated Container initContainers = 20;

  // List of containers belonging to the pod.
  // Containers cannot currently be added or removed.
  // There must be at least one container in a Pod.
  // Cannot be updated.
  // +patchMergeKey=name
  // +patchStrategy=merge
  repeated Container containers = 2;

  // Restart policy for all containers within the pod.
  // One of Always, OnFailure, Never.
  // Default to Always.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
  // +optional
  optional string restartPolicy = 3;

  // Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.
  // Value must be non-negative integer. The value zero indicates delete immediately.
  // If this value is nil, the default grace period will be used instead.
  // The grace period is the duration in seconds after the processes running in the pod are sent
  // a termination signal and the time when the processes are forcibly halted with a kill signal.
  // Set this value longer than the expected cleanup time for your process.
  // Defaults to 30 seconds.
  // +optional
  optional int64 terminationGracePeriodSeconds = 4;

  // Optional duration in seconds the pod may be active on the node relative to
  // StartTime before the system will actively try to mark it failed and kill associated containers.
  // Value must be a positive integer.
  // +optional
  optional int64 activeDeadlineSeconds = 5;

  // Set DNS policy for containers within the pod.
  // One of 'ClusterFirstWithHostNet', 'ClusterFirst' or 'Default'.
  // Defaults to "ClusterFirst".
  // To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.
  // +optional
  optional string dnsPolicy = 6;

  // NodeSelector is a selector which must be true for the pod to fit on a node.
  // Selector which must match a node's labels for the pod to be scheduled on that node.
  // More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
  // +optional
  map<string, string> nodeSelector = 7;

  // ServiceAccountName is the name of the ServiceAccount to use to run this pod.
  // More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
  // +optional
  optional string serviceAccountName = 8;

  // DeprecatedServiceAccount is a depreciated alias for ServiceAccountName.
  // Deprecated: Use serviceAccountName instead.
  // +k8s:conversion-gen=false
  // +optional
  optional string serviceAccount = 9;

  // AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
  // +optional
  optional bool automountServiceAccountToken = 21;

  // NodeName is a request to schedule this pod onto a specific node. If it is non-empty,
  // the scheduler simply schedules this pod onto that node, assuming that it fits resource
  // requirements.
  // +optional
  optional string nodeName = 10;

  // Host networking requested for this pod. Use the host's network namespace.
  // If this option is set, the ports that will be used must be specified.
  // Default to false.
  // +k8s:conversion-gen=false
  // +optional
  optional bool hostNetwork = 11;

  // Use the host's pid namespace.
  // Optional: Default to false.
  // +k8s:conversion-gen=false
  // +optional
  optional bool hostPID = 12;

  // Use the host's ipc namespace.
  // Optional: Default to false.
  // +k8s:conversion-gen=false
  // +optional
  optional bool hostIPC = 13;

  // SecurityContext holds pod-level security attributes and common container settings.
  // Optional: Defaults to empty.  See type description for default values of each field.
  // +optional
  optional PodSecurityContext securityContext = 14;

  // ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
  // If specified, these secrets will be passed to individual puller implementations for them to use. For example,
  // in the case of docker, only DockerConfig type secrets are honored.
  // More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
  // +optional
  // +patchMergeKey=name
  // +patchStrategy=merge
  repeated github.com.openshift.origin.pkg.build.apis.build.v1.LocalObjectReference imagePullSecrets = 15;

  // Specifies the hostname of the Pod
  // If not specified, the pod's hostname will be set to a system-defined value.
  // +optional
  optional string hostname = 16;

  // If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>".
  // If not specified, the pod will not have a domainname at all.
  // +optional
  optional string subdomain = 17;

  // If specified, the pod's scheduling constraints
  // +optional
  optional Affinity affinity = 18;

  // If specified, the pod will be dispatched by specified scheduler.
  // If not specified, the pod will be dispatched by default scheduler.
  // +optional
  optional string schedulerName = 19;

  // If specified, the pod's tolerations.
  // +optional
  repeated Toleration tolerations = 22;

  // HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts
  // file if specified. This is only valid for non-hostNetwork pods.
  // +optional
  // +patchMergeKey=ip
  // +patchStrategy=merge
  repeated HostAlias hostAliases = 23;

  // If specified, indicates the pod's priority. "SYSTEM" is a special keyword
  // which indicates the highest priority. Any other name must be defined by
  // creating a PriorityClass object with that name.
  // If not specified, the pod priority will be default or zero if there is no
  // default.
  // +optional
  optional string priorityClassName = 24;

  // The priority value. Various system components use this field to find the
  // priority of the pod. When Priority Admission Controller is enabled, it
  // prevents users from setting this field. The admission controller populates
  // this field from PriorityClassName.
  // The higher the value, the higher the priority.
  // +optional
  optional int32 priority = 25;
}

message PodTemplateSpec {
  // Standard object's metadata.
  // More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  // Specification of the desired behavior of the pod.
  // More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
  // +optional
  optional PodSpec spec = 2;
}

message PortworxVolumeSource {
  // VolumeID uniquely identifies a Portworx volume
  optional string volumeID = 1;

  // FSType represents the filesystem type to mount
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
  optional string fsType = 2;

  // Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // +optional
  optional bool readOnly = 3;
}

message PreferredSchedulingTerm {
  // Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
  optional int32 weight = 1;

  // A node selector term, associated with the corresponding weight.
  optional NodeSelectorTerm preference = 2;
}

message Probe {
  // The action taken to determine the health of a container
  optional Handler handler = 1;

  // Number of seconds after the container has started before liveness probes are initiated.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  // +optional
  optional int32 initialDelaySeconds = 2;

  // Number of seconds after which the probe times out.
  // Defaults to 1 second. Minimum value is 1.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  // +optional
  optional int32 timeoutSeconds = 3;

  // How often (in seconds) to perform the probe.
  // Default to 10 seconds. Minimum value is 1.
  // +optional
  optional int32 periodSeconds = 4;

  // Minimum consecutive successes for the probe to be considered successful after having failed.
  // Defaults to 1. Must be 1 for liveness. Minimum value is 1.
  // +optional
  optional int32 successThreshold = 5;

  // Minimum consecutive failures for the probe to be considered failed after having succeeded.
  // Defaults to 3. Minimum value is 1.
  // +optional
  optional int32 failureThreshold = 6;
}

message ProjectedVolumeSource {
  // list of volume projections
  repeated VolumeProjection sources = 1;

  // Mode bits to use on created files by default. Must be a value between
  // 0 and 0777.
  // Directories within the path are not affected by this setting.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  // +optional
  optional int32 defaultMode = 2;
}

message QuobyteVolumeSource {
  // Registry represents a single or multiple Quobyte Registry services
  // specified as a string as host:port pair (multiple entries are separated with commas)
  // which acts as the central registry for volumes
  optional string registry = 1;

  // Volume is a string that references an already created Quobyte volume by name.
  optional string volume = 2;

  // ReadOnly here will force the Quobyte volume to be mounted with read-only permissions.
  // Defaults to false.
  // +optional
  optional bool readOnly = 3;

  // User to map volume access to
  // Defaults to serivceaccount user
  // +optional
  optional string user = 4;

  // Group to map volume access to
  // Default is no group
  // +optional
  optional string group = 5;
}

message RBDVolumeSource {
  // A collection of Ceph monitors.
  // More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
  repeated string monitors = 1;

  // The rados image name.
  // More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
  optional string image = 2;

  // Filesystem type of the volume that you want to mount.
  // Tip: Ensure that the filesystem type is supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
  // TODO: how do we prevent errors in the filesystem from compromising the machine
  // +optional
  optional string fsType = 3;

  // The rados pool name.
  // Default is rbd.
  // More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
  // +optional
  optional string pool = 4;

  // The rados user name.
  // Default is admin.
  // More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
  // +optional
  optional string user = 5;

  // Keyring is the path to key ring for RBDUser.
  // Default is /etc/ceph/keyring.
  // More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
  // +optional
  optional string keyring = 6;

  // SecretRef is name of the authentication secret for RBDUser. If provided
  // overrides keyring.
  // Default is nil.
  // More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
  // +optional
  optional github.com.openshift.origin.pkg.build.apis.build.v1.LocalObjectReference secretRef = 7;

  // ReadOnly here will force the ReadOnly setting in VolumeMounts.
  // Defaults to false.
  // More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
  // +optional
  optional bool readOnly = 8;
}

message SELinuxOptions {
  // User is a SELinux user label that applies to the container.
  // +optional
  optional string user = 1;

  // Role is a SELinux role label that applies to the container.
  // +optional
  optional string role = 2;

  // Type is a SELinux type label that applies to the container.
  // +optional
  optional string type = 3;

  // Level is SELinux level label that applies to the container.
  // +optional
  optional string level = 4;
}

message ScaleIOVolumeSource {
  // The host address of the ScaleIO API Gateway.
  optional string gateway = 1;

  // The name of the storage system as configured in ScaleIO.
  optional string system = 2;

  // SecretRef references to the secret for ScaleIO user and other
  // sensitive information. If this is not provided, Login operation will fail.
  optional github.com.openshift.origin.pkg.build.apis.build.v1.LocalObjectReference secretRef = 3;

  // Flag to enable/disable SSL communication with Gateway, default false
  // +optional
  optional bool sslEnabled = 4;

  // The name of the Protection Domain for the configured storage (defaults to "default").
  // +optional
  optional string protectionDomain = 5;

  // The Storage Pool associated with the protection domain (defaults to "default").
  // +optional
  optional string storagePool = 6;

  // Indicates whether the storage for a volume should be thick or thin (defaults to "thin").
  // +optional
  optional string storageMode = 7;

  // The name of a volume already created in the ScaleIO system
  // that is associated with this volume source.
  optional string volumeName = 8;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // +optional
  optional string fsType = 9;

  // Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // +optional
  optional bool readOnly = 10;
}

message SecretEnvSource {
  // The Secret to select from.
  optional github.com.openshift.origin.pkg.build.apis.build.v1.LocalObjectReference localObjectReference = 1;

  // Specify whether the Secret must be defined
  // +optional
  optional bool optional = 2;
}

message SecretProjection {
  optional github.com.openshift.origin.pkg.build.apis.build.v1.LocalObjectReference localObjectReference = 1;

  // If unspecified, each key-value pair in the Data field of the referenced
  // Secret will be projected into the volume as a file whose name is the
  // key and content is the value. If specified, the listed keys will be
  // projected into the specified paths, and unlisted keys will not be
  // present. If a key is specified which is not present in the Secret,
  // the volume setup will error unless it is marked optional. Paths must be
  // relative and may not contain the '..' path or start with '..'.
  // +optional
  repeated KeyToPath items = 2;

  // Specify whether the Secret or its key must be defined
  // +optional
  optional bool optional = 4;
}

message SecretVolumeSource {
  // Name of the secret in the pod's namespace to use.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
  // +optional
  optional string secretName = 1;

  // If unspecified, each key-value pair in the Data field of the referenced
  // Secret will be projected into the volume as a file whose name is the
  // key and content is the value. If specified, the listed keys will be
  // projected into the specified paths, and unlisted keys will not be
  // present. If a key is specified which is not present in the Secret,
  // the volume setup will error unless it is marked optional. Paths must be
  // relative and may not contain the '..' path or start with '..'.
  // +optional
  repeated KeyToPath items = 2;

  // Optional: mode bits to use on created files by default. Must be a
  // value between 0 and 0777. Defaults to 0644.
  // Directories within the path are not affected by this setting.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  // +optional
  optional int32 defaultMode = 3;

  // Specify whether the Secret or it's keys must be defined
  // +optional
  optional bool optional = 4;
}

message SecurityContext {
  // The capabilities to add/drop when running containers.
  // Defaults to the default set of capabilities granted by the container runtime.
  // +optional
  optional Capabilities capabilities = 1;

  // Run container in privileged mode.
  // Processes in privileged containers are essentially equivalent to root on the host.
  // Defaults to false.
  // +optional
  optional bool privileged = 2;

  // The SELinux context to be applied to the container.
  // If unspecified, the container runtime will allocate a random SELinux context for each
  // container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
  // PodSecurityContext, the value specified in SecurityContext takes precedence.
  // +optional
  optional SELinuxOptions seLinuxOptions = 3;

  // The UID to run the entrypoint of the container process.
  // Defaults to user specified in image metadata if unspecified.
  // May also be set in PodSecurityContext.  If set in both SecurityContext and
  // PodSecurityContext, the value specified in SecurityContext takes precedence.
  // +optional
  optional int64 runAsUser = 4;

  // Indicates that the container must run as a non-root user.
  // If true, the Kubelet will validate the image at runtime to ensure that it
  // does not run as UID 0 (root) and fail to start the container if it does.
  // If unset or false, no such validation will be performed.
  // May also be set in PodSecurityContext.  If set in both SecurityContext and
  // PodSecurityContext, the value specified in SecurityContext takes precedence.
  // +optional
  optional bool runAsNonRoot = 5;

  // Whether this container has a read-only root filesystem.
  // Default is false.
  // +optional
  optional bool readOnlyRootFilesystem = 6;

  // AllowPrivilegeEscalation controls whether a process can gain more
  // privileges than its parent process. This bool directly controls if
  // the no_new_privs flag will be set on the container process.
  // AllowPrivilegeEscalation is true always when the container is:
  // 1) run as Privileged
  // 2) has CAP_SYS_ADMIN
  // +optional
  optional bool allowPrivilegeEscalation = 7;
}

message StorageOSVolumeSource {
  // VolumeName is the human-readable name of the StorageOS volume.  Volume
  // names are only unique within a namespace.
  optional string volumeName = 1;

  // VolumeNamespace specifies the scope of the volume within StorageOS.  If no
  // namespace is specified then the Pod's namespace will be used.  This allows the
  // Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
  // Set VolumeName to any name to override the default behaviour.
  // Set to "default" if you are not using namespaces within StorageOS.
  // Namespaces that do not pre-exist within StorageOS will be created.
  // +optional
  optional string volumeNamespace = 2;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // +optional
  optional string fsType = 3;

  // Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // +optional
  optional bool readOnly = 4;

  // SecretRef specifies the secret to use for obtaining the StorageOS API
  // credentials.  If not specified, default values will be attempted.
  // +optional
  optional github.com.openshift.origin.pkg.build.apis.build.v1.LocalObjectReference secretRef = 5;
}

message TCPSocketAction {
  // Number or name of the port to access on the container.
  // Number must be in the range 1 to 65535.
  // Name must be an IANA_SVC_NAME.
  optional k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 1;

  // Optional: Host name to connect to, defaults to the pod IP.
  // +optional
  optional string host = 2;
}

message Toleration {
  // Key is the taint key that the toleration applies to. Empty means match all taint keys.
  // If the key is empty, operator must be Exists; this combination means to match all values and all keys.
  // +optional
  optional string key = 1;

  // Operator represents a key's relationship to the value.
  // Valid operators are Exists and Equal. Defaults to Equal.
  // Exists is equivalent to wildcard for value, so that a pod can
  // tolerate all taints of a particular category.
  // +optional
  optional string operator = 2;

  // Value is the taint value the toleration matches to.
  // If the operator is Exists, the value should be empty, otherwise just a regular string.
  // +optional
  optional string value = 3;

  // Effect indicates the taint effect to match. Empty means match all taint effects.
  // When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
  // +optional
  optional string effect = 4;

  // TolerationSeconds represents the period of time the toleration (which must be
  // of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
  // it is not set, which means tolerate the taint forever (do not evict). Zero and
  // negative values will be treated as 0 (evict immediately) by the system.
  // +optional
  optional int64 tolerationSeconds = 5;
}

message Volume {
  // Volume's name.
  // Must be a DNS_LABEL and unique within the pod.
  // More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  optional string name = 1;

  // VolumeSource represents the location and type of the mounted volume.
  // If not specified, the Volume is implied to be an EmptyDir.
  // This implied behavior is deprecated and will be removed in a future version.
  optional VolumeSource volumeSource = 2;
}

message VolumeMount {
  // This must match the Name of a Volume.
  optional string name = 1;

  // Mounted read-only if true, read-write otherwise (false or unspecified).
  // Defaults to false.
  // +optional
  optional bool readOnly = 2;

  // Path within the container at which the volume should be mounted.  Must
  // not contain ':'.
  optional string mountPath = 3;

  // Path within the volume from which the container's volume should be mounted.
  // Defaults to "" (volume's root).
  // +optional
  optional string subPath = 4;

  // mountPropagation determines how mounts are propagated from the host
  // to container and the other way around.
  // When not set, MountPropagationHostToContainer is used.
  // This field is alpha in 1.8 and can be reworked or removed in a future
  // release.
  // +optional
  optional string mountPropagation = 5;
}

message VolumeProjection {
  // information about the secret data to project
  optional SecretProjection secret = 1;

  // information about the downwardAPI data to project
  optional DownwardAPIProjection downwardAPI = 2;

  // information about the configMap data to project
  optional ConfigMapProjection configMap = 3;
}

message VolumeSource {
  // HostPath represents a pre-existing file or directory on the host
  // machine that is directly exposed to the container. This is generally
  // used for system agents or other privileged things that are allowed
  // to see the host machine. Most containers will NOT need this.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
  // ---
  // TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
  // mount host directories as read/write.
  // +optional
  optional HostPathVolumeSource hostPath = 1;

  // EmptyDir represents a temporary directory that shares a pod's lifetime.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
  // +optional
  optional EmptyDirVolumeSource emptyDir = 2;

  // GCEPersistentDisk represents a GCE Disk resource that is attached to a
  // kubelet's host machine and then exposed to the pod.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  // +optional
  optional GCEPersistentDiskVolumeSource gcePersistentDisk = 3;

  // AWSElasticBlockStore represents an AWS Disk resource that is attached to a
  // kubelet's host machine and then exposed to the pod.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
  // +optional
  optional AWSElasticBlockStoreVolumeSource awsElasticBlockStore = 4;

  // GitRepo represents a git repository at a particular revision.
  // +optional
  optional GitRepoVolumeSource gitRepo = 5;

  // Secret represents a secret that should populate this volume.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
  // +optional
  optional SecretVolumeSource secret = 6;

  // NFS represents an NFS mount on the host that shares a pod's lifetime
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
  // +optional
  optional NFSVolumeSource nfs = 7;

  // ISCSI represents an ISCSI Disk resource that is attached to a
  // kubelet's host machine and then exposed to the pod.
  // More info: https://releases.k8s.io/HEAD/examples/volumes/iscsi/README.md
  // +optional
  optional ISCSIVolumeSource iscsi = 8;

  // Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
  // More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md
  // +optional
  optional GlusterfsVolumeSource glusterfs = 9;

  // PersistentVolumeClaimVolumeSource represents a reference to a
  // PersistentVolumeClaim in the same namespace.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
  // +optional
  optional PersistentVolumeClaimVolumeSource persistentVolumeClaim = 10;

  // RBD represents a Rados Block Device mount on the host that shares a pod's lifetime.
  // More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md
  // +optional
  optional RBDVolumeSource rbd = 11;

  // FlexVolume represents a generic volume resource that is
  // provisioned/attached using an exec based plugin. This is an
  // alpha feature and may change in future.
  // +optional
  optional FlexVolumeSource flexVolume = 12;

  // Cinder represents a cinder volume attached and mounted on kubelets host machine
  // More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
  // +optional
  optional CinderVolumeSource cinder = 13;

  // CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
  // +optional
  optional CephFSVolumeSource cephfs = 14;

  // Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
  // +optional
  optional FlockerVolumeSource flocker = 15;

  // DownwardAPI represents downward API about the pod that should populate this volume
  // +optional
  optional DownwardAPIVolumeSource downwardAPI = 16;

  // FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
  // +optional
  optional FCVolumeSource fc = 17;

  // AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
  // +optional
  optional AzureFileVolumeSource azureFile = 18;

  // ConfigMap represents a configMap that should populate this volume
  // +optional
  optional ConfigMapVolumeSource configMap = 19;

  // VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
  // +optional
  optional VsphereVirtualDiskVolumeSource vsphereVolume = 20;

  // Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
  // +optional
  optional QuobyteVolumeSource quobyte = 21;

  // AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
  // +optional
  optional AzureDiskVolumeSource azureDisk = 22;

  // PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
  optional PhotonPersistentDiskVolumeSource photonPersistentDisk = 23;

  // Items for all in one resources secrets, configmaps, and downward API
  optional ProjectedVolumeSource projected = 26;

  // PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
  // +optional
  optional PortworxVolumeSource portworxVolume = 24;

  // ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
  // +optional
  optional ScaleIOVolumeSource scaleIO = 25;

  // StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
  // +optional
  optional StorageOSVolumeSource storageos = 27;
}

message VsphereVirtualDiskVolumeSource {
  // Path that identifies vSphere volume vmdk
  optional string volumePath = 1;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // +optional
  optional string fsType = 2;

  // Storage Policy Based Management (SPBM) profile name.
  // +optional
  optional string storagePolicyName = 3;

  // Storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
  // +optional
  optional string storagePolicyID = 4;
}

message WeightedPodAffinityTerm {
  // weight associated with matching the corresponding podAffinityTerm,
  // in the range 1-100.
  optional int32 weight = 1;

  // Required. A pod affinity term, associated with the corresponding weight.
  optional PodAffinityTerm podAffinityTerm = 2;
}

// CustomDeploymentStrategyParams are the input to the Custom deployment strategy.
message CustomDeploymentStrategyParams {
  // Image specifies a Docker image which can carry out a deployment.
  optional string image = 1;

  // Environment holds the environment which will be given to the container for Image.
  repeated github.com.openshift.origin.pkg.build.apis.build.v1.EnvVar environment = 2;

  // Command is optional and overrides CMD in the container Image.
  repeated string command = 3;
}

// DeploymentCause captures information about a particular cause of a deployment.
message DeploymentCause {
  // Type of the trigger that resulted in the creation of a new deployment
  optional string type = 1;

  // ImageTrigger contains the image trigger details, if this trigger was fired based on an image change
  optional DeploymentCauseImageTrigger imageTrigger = 2;
}

// DeploymentCauseImageTrigger represents details about the cause of a deployment originating
// from an image change trigger
message DeploymentCauseImageTrigger {
  // From is a reference to the changed object which triggered a deployment. The field may have
  // the kinds DockerImage, ImageStreamTag, or ImageStreamImage.
  optional github.com.openshift.origin.pkg.authorization.apis.authorization.v1.ObjectReference from = 1;
}

// DeploymentCondition describes the state of a deployment config at a certain point.
message DeploymentCondition {
  // Type of deployment condition.
  optional string type = 1;

  // Status of the condition, one of True, False, Unknown.
  optional string status = 2;

  // The last time this condition was updated.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 6;

  // The last time the condition transitioned from one status to another.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;

  // The reason for the condition's last transition.
  optional string reason = 4;

  // A human readable message indicating details about the transition.
  optional string message = 5;
}

// Deployment Configs define the template for a pod and manages deploying new images or configuration changes.
// A single deployment configuration is usually analogous to a single micro-service. Can support many different
// deployment patterns, including full restart, customizable rolling updates, and  fully custom behaviors, as
// well as pre- and post- deployment hooks. Each individual deployment is represented as a replication controller.
// 
// A deployment is "triggered" when its configuration is changed or a tag in an Image Stream is changed.
// Triggers can be disabled to allow manual control over a deployment. The "strategy" determines how the deployment
// is carried out and may be changed at any time. The `latestVersion` field is updated when a new deployment
// is triggered by any means.
message DeploymentConfig {
  // Standard object's metadata.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  // Spec represents a desired deployment state and how to deploy to it.
  optional DeploymentConfigSpec spec = 2;

  // Status represents the current deployment state.
  optional DeploymentConfigStatus status = 3;
}

// DeploymentConfigList is a collection of deployment configs.
message DeploymentConfigList {
  // Standard object's metadata.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  // Items is a list of deployment configs
  repeated DeploymentConfig items = 2;
}

// DeploymentConfigRollback provides the input to rollback generation.
message DeploymentConfigRollback {
  // Name of the deployment config that will be rolled back.
  optional string name = 1;

  // UpdatedAnnotations is a set of new annotations that will be added in the deployment config.
  map<string, string> updatedAnnotations = 2;

  // Spec defines the options to rollback generation.
  optional DeploymentConfigRollbackSpec spec = 3;
}

// DeploymentConfigRollbackSpec represents the options for rollback generation.
message DeploymentConfigRollbackSpec {
  // From points to a ReplicationController which is a deployment.
  optional github.com.openshift.origin.pkg.authorization.apis.authorization.v1.ObjectReference from = 1;

  // Revision to rollback to. If set to 0, rollback to the last revision.
  optional int64 revision = 2;

  // IncludeTriggers specifies whether to include config Triggers.
  optional bool includeTriggers = 3;

  // IncludeTemplate specifies whether to include the PodTemplateSpec.
  optional bool includeTemplate = 4;

  // IncludeReplicationMeta specifies whether to include the replica count and selector.
  optional bool includeReplicationMeta = 5;

  // IncludeStrategy specifies whether to include the deployment Strategy.
  optional bool includeStrategy = 6;
}

// DeploymentConfigSpec represents the desired state of the deployment.
message DeploymentConfigSpec {
  // Strategy describes how a deployment is executed.
  optional DeploymentStrategy strategy = 1;

  // MinReadySeconds is the minimum number of seconds for which a newly created pod should
  // be ready without any of its container crashing, for it to be considered available.
  // Defaults to 0 (pod will be considered available as soon as it is ready)
  optional int32 minReadySeconds = 9;

  // Triggers determine how updates to a DeploymentConfig result in new deployments. If no triggers
  // are defined, a new deployment can only occur as a result of an explicit client update to the
  // DeploymentConfig with a new LatestVersion. If null, defaults to having a config change trigger.
  optional DeploymentTriggerPolicies triggers = 2;

  // Replicas is the number of desired replicas.
  optional int32 replicas = 3;

  // RevisionHistoryLimit is the number of old ReplicationControllers to retain to allow for rollbacks.
  // This field is a pointer to allow for differentiation between an explicit zero and not specified.
  // Defaults to 10. (This only applies to DeploymentConfigs created via the new group API resource, not the legacy resource.)
  optional int32 revisionHistoryLimit = 4;

  // Test ensures that this deployment config will have zero replicas except while a deployment is running. This allows the
  // deployment config to be used as a continuous deployment test - triggering on images, running the deployment, and then succeeding
  // or failing. Post strategy hooks and After actions can be used to integrate successful deployment with an action.
  optional bool test = 5;

  // Paused indicates that the deployment config is paused resulting in no new deployments on template
  // changes or changes in the template caused by other triggers.
  optional bool paused = 6;

  // Selector is a label query over pods that should match the Replicas count.
  map<string, string> selector = 7;

  // Template is the object that describes the pod that will be created if
  // insufficient replicas are detected.
  optional PodTemplateSpec template = 8;
}

// DeploymentConfigStatus represents the current deployment state.
message DeploymentConfigStatus {
  // LatestVersion is used to determine whether the current deployment associated with a deployment
  // config is out of sync.
  optional int64 latestVersion = 1;

  // ObservedGeneration is the most recent generation observed by the deployment config controller.
  optional int64 observedGeneration = 2;

  // Replicas is the total number of pods targeted by this deployment config.
  optional int32 replicas = 3;

  // UpdatedReplicas is the total number of non-terminated pods targeted by this deployment config
  // that have the desired template spec.
  optional int32 updatedReplicas = 4;

  // AvailableReplicas is the total number of available pods targeted by this deployment config.
  optional int32 availableReplicas = 5;

  // UnavailableReplicas is the total number of unavailable pods targeted by this deployment config.
  optional int32 unavailableReplicas = 6;

  // Details are the reasons for the update to this deployment config.
  // This could be based on a change made by the user or caused by an automatic trigger
  optional DeploymentDetails details = 7;

  // Conditions represents the latest available observations of a deployment config's current state.
  // +patchMergeKey=type
  // +patchStrategy=merge
  repeated DeploymentCondition conditions = 8;

  // Total number of ready pods targeted by this deployment.
  optional int32 readyReplicas = 9;
}

// DeploymentDetails captures information about the causes of a deployment.
message DeploymentDetails {
  // Message is the user specified change message, if this deployment was triggered manually by the user
  optional string message = 1;

  // Causes are extended data associated with all the causes for creating a new deployment
  repeated DeploymentCause causes = 2;
}

// DeploymentLog represents the logs for a deployment
message DeploymentLog {
}

// DeploymentLogOptions is the REST options for a deployment log
message DeploymentLogOptions {
  // The container for which to stream logs. Defaults to only container if there is one container in the pod.
  optional string container = 1;

  // Follow if true indicates that the build log should be streamed until
  // the build terminates.
  optional bool follow = 2;

  // Return previous deployment logs. Defaults to false.
  optional bool previous = 3;

  // A relative time in seconds before the current time from which to show logs. If this value
  // precedes the time a pod was started, only logs since the pod start will be returned.
  // If this value is in the future, no logs will be returned.
  // Only one of sinceSeconds or sinceTime may be specified.
  optional int64 sinceSeconds = 4;

  // An RFC3339 timestamp from which to show logs. If this value
  // precedes the time a pod was started, only logs since the pod start will be returned.
  // If this value is in the future, no logs will be returned.
  // Only one of sinceSeconds or sinceTime may be specified.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time sinceTime = 5;

  // If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line
  // of log output. Defaults to false.
  optional bool timestamps = 6;

  // If set, the number of lines from the end of the logs to show. If not specified,
  // logs are shown from the creation of the container or sinceSeconds or sinceTime
  optional int64 tailLines = 7;

  // If set, the number of bytes to read from the server before terminating the
  // log output. This may not display a complete final line of logging, and may return
  // slightly more or slightly less than the specified limit.
  optional int64 limitBytes = 8;

  // NoWait if true causes the call to return immediately even if the deployment
  // is not available yet. Otherwise the server will wait until the deployment has started.
  // TODO: Fix the tag to 'noWait' in v2
  optional bool nowait = 9;

  // Version of the deployment for which to view logs.
  optional int64 version = 10;
}

// DeploymentRequest is a request to a deployment config for a new deployment.
message DeploymentRequest {
  // Name of the deployment config for requesting a new deployment.
  optional string name = 1;

  // Latest will update the deployment config with the latest state from all triggers.
  optional bool latest = 2;

  // Force will try to force a new deployment to run. If the deployment config is paused,
  // then setting this to true will return an Invalid error.
  optional bool force = 3;

  // ExcludeTriggers instructs the instantiator to avoid processing the specified triggers.
  // This field overrides the triggers from latest and allows clients to control specific
  // logic. This field is ignored if not specified.
  repeated string excludeTriggers = 4;
}

// DeploymentStrategy describes how to perform a deployment.
message DeploymentStrategy {
  // Type is the name of a deployment strategy.
  optional string type = 1;

  // CustomParams are the input to the Custom deployment strategy, and may also
  // be specified for the Recreate and Rolling strategies to customize the execution
  // process that runs the deployment.
  optional CustomDeploymentStrategyParams customParams = 2;

  // RecreateParams are the input to the Recreate deployment strategy.
  optional RecreateDeploymentStrategyParams recreateParams = 3;

  // RollingParams are the input to the Rolling deployment strategy.
  optional RollingDeploymentStrategyParams rollingParams = 4;

  // Resources contains resource requirements to execute the deployment and any hooks.
  optional github.com.openshift.origin.pkg.build.apis.build.v1.ResourceRequirements resources = 5;

  // Labels is a set of key, value pairs added to custom deployer and lifecycle pre/post hook pods.
  map<string, string> labels = 6;

  // Annotations is a set of key, value pairs added to custom deployer and lifecycle pre/post hook pods.
  map<string, string> annotations = 7;

  // ActiveDeadlineSeconds is the duration in seconds that the deployer pods for this deployment
  // config may be active on a node before the system actively tries to terminate them.
  optional int64 activeDeadlineSeconds = 8;
}

// DeploymentTriggerImageChangeParams represents the parameters to the ImageChange trigger.
message DeploymentTriggerImageChangeParams {
  // Automatic means that the detection of a new tag value should result in an image update
  // inside the pod template.
  optional bool automatic = 1;

  // ContainerNames is used to restrict tag updates to the specified set of container names in a pod.
  // If multiple triggers point to the same containers, the resulting behavior is undefined. Future
  // API versions will make this a validation error. If ContainerNames does not point to a valid container,
  // the trigger will be ignored. Future API versions will make this a validation error.
  repeated string containerNames = 2;

  // From is a reference to an image stream tag to watch for changes. From.Name is the only
  // required subfield - if From.Namespace is blank, the namespace of the current deployment
  // trigger will be used.
  optional github.com.openshift.origin.pkg.authorization.apis.authorization.v1.ObjectReference from = 3;

  // LastTriggeredImage is the last image to be triggered.
  optional string lastTriggeredImage = 4;
}

// DeploymentTriggerPolicies is a list of policies where nil values and different from empty arrays.
// +protobuf.nullable=true
// +protobuf.options.(gogoproto.goproto_stringer)=false
message DeploymentTriggerPolicies {
  // items, if empty, will result in an empty slice

  repeated DeploymentTriggerPolicy items = 1;
}

// DeploymentTriggerPolicy describes a policy for a single trigger that results in a new deployment.
message DeploymentTriggerPolicy {
  // Type of the trigger
  optional string type = 1;

  // ImageChangeParams represents the parameters for the ImageChange trigger.
  optional DeploymentTriggerImageChangeParams imageChangeParams = 2;
}

// ExecNewPodHook is a hook implementation which runs a command in a new pod
// based on the specified container which is assumed to be part of the
// deployment template.
message ExecNewPodHook {
  // Command is the action command and its arguments.
  repeated string command = 1;

  // Env is a set of environment variables to supply to the hook pod's container.
  repeated github.com.openshift.origin.pkg.build.apis.build.v1.EnvVar env = 2;

  // ContainerName is the name of a container in the deployment pod template
  // whose Docker image will be used for the hook pod's container.
  optional string containerName = 3;

  // Volumes is a list of named volumes from the pod template which should be
  // copied to the hook pod. Volumes names not found in pod spec are ignored.
  // An empty list means no volumes will be copied.
  repeated string volumes = 4;
}

// LifecycleHook defines a specific deployment lifecycle action. Only one type of action may be specified at any time.
message LifecycleHook {
  // FailurePolicy specifies what action to take if the hook fails.
  optional string failurePolicy = 1;

  // ExecNewPod specifies the options for a lifecycle hook backed by a pod.
  optional ExecNewPodHook execNewPod = 2;

  // TagImages instructs the deployer to tag the current image referenced under a container onto an image stream tag.
  repeated TagImageHook tagImages = 3;
}

// RecreateDeploymentStrategyParams are the input to the Recreate deployment
// strategy.
message RecreateDeploymentStrategyParams {
  // TimeoutSeconds is the time to wait for updates before giving up. If the
  // value is nil, a default will be used.
  optional int64 timeoutSeconds = 1;

  // Pre is a lifecycle hook which is executed before the strategy manipulates
  // the deployment. All LifecycleHookFailurePolicy values are supported.
  optional LifecycleHook pre = 2;

  // Mid is a lifecycle hook which is executed while the deployment is scaled down to zero before the first new
  // pod is created. All LifecycleHookFailurePolicy values are supported.
  optional LifecycleHook mid = 3;

  // Post is a lifecycle hook which is executed after the strategy has
  // finished all deployment logic. All LifecycleHookFailurePolicy values are supported.
  optional LifecycleHook post = 4;
}

// RollingDeploymentStrategyParams are the input to the Rolling deployment
// strategy.
message RollingDeploymentStrategyParams {
  // UpdatePeriodSeconds is the time to wait between individual pod updates.
  // If the value is nil, a default will be used.
  optional int64 updatePeriodSeconds = 1;

  // IntervalSeconds is the time to wait between polling deployment status
  // after update. If the value is nil, a default will be used.
  optional int64 intervalSeconds = 2;

  // TimeoutSeconds is the time to wait for updates before giving up. If the
  // value is nil, a default will be used.
  optional int64 timeoutSeconds = 3;

  // MaxUnavailable is the maximum number of pods that can be unavailable
  // during the update. Value can be an absolute number (ex: 5) or a
  // percentage of total pods at the start of update (ex: 10%). Absolute
  // number is calculated from percentage by rounding down.
  // 
  // This cannot be 0 if MaxSurge is 0. By default, 25% is used.
  // 
  // Example: when this is set to 30%, the old RC can be scaled down by 30%
  // immediately when the rolling update starts. Once new pods are ready, old
  // RC can be scaled down further, followed by scaling up the new RC,
  // ensuring that at least 70% of original number of pods are available at
  // all times during the update.
  optional k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 4;

  // MaxSurge is the maximum number of pods that can be scheduled above the
  // original number of pods. Value can be an absolute number (ex: 5) or a
  // percentage of total pods at the start of the update (ex: 10%). Absolute
  // number is calculated from percentage by rounding up.
  // 
  // This cannot be 0 if MaxUnavailable is 0. By default, 25% is used.
  // 
  // Example: when this is set to 30%, the new RC can be scaled up by 30%
  // immediately when the rolling update starts. Once old pods have been
  // killed, new RC can be scaled up further, ensuring that total number of
  // pods running at any time during the update is atmost 130% of original
  // pods.
  optional k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 5;

  // Pre is a lifecycle hook which is executed before the deployment process
  // begins. All LifecycleHookFailurePolicy values are supported.
  optional LifecycleHook pre = 7;

  // Post is a lifecycle hook which is executed after the strategy has
  // finished all deployment logic. All LifecycleHookFailurePolicy values
  // are supported.
  optional LifecycleHook post = 8;
}

// TagImageHook is a request to tag the image in a particular container onto an ImageStreamTag.
message TagImageHook {
  // ContainerName is the name of a container in the deployment config whose image value will be used as the source of the tag. If there is only a single
  // container this value will be defaulted to the name of that container.
  optional string containerName = 1;

  // To is the target ImageStreamTag to set the container's image onto.
  optional github.com.openshift.origin.pkg.authorization.apis.authorization.v1.ObjectReference to = 2;
}

